Option Explicit

Sub StackAllSheets_AllContent_WithTabInColA_KeepFormatting()
    Dim wb As Workbook: Set wb = ActiveWorkbook
    Dim ws As Worksheet, wsOut As Worksheet
    Dim destRow As Long, lastRow As Long, lastCol As Long
    Dim rngBlock As Range
    Dim outName As String
    Dim r As Long, c As Long
    Dim rowsCount As Long, colsCount As Long
    
    ' --- Réglages ---
    Const ADD_BLANK_LINE_BETWEEN As Boolean = True
    Const COPY_SHAPES_TOO As Boolean = False   ' Passez à True si vous voulez copier aussi images/graphes
    
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual
    
    ' Créer la feuille de sortie (nom unique, aucune suppression)
    outName = UniqueSheetName(wb, "StackResult")
    On Error GoTo AddErr
    Set wsOut = wb.Worksheets.Add(After:=wb.Worksheets(wb.Worksheets.Count))
    wsOut.Name = outName
    On Error GoTo 0
    
    destRow = 1
    
    For Each ws In wb.Worksheets
        If ws.Name <> wsOut.Name Then
            
            ' Détecter la zone réellement utilisée
            On Error Resume Next
            lastRow = 0: lastCol = 0
            lastRow = ws.Cells.Find(What:="*", LookIn:=xlFormulas, _
                                    SearchOrder:=xlByRows, SearchDirection:=xlPrevious).Row
            lastCol = ws.Cells.Find(What:="*", LookIn:=xlFormulas, _
                                    SearchOrder:=xlByColumns, SearchDirection:=xlPrevious).Column
            On Error GoTo 0
            
            If lastRow > 0 And lastCol > 0 Then
                Set rngBlock = ws.Range(ws.Cells(1, 1), ws.Cells(lastRow, lastCol))
                rowsCount = rngBlock.Rows.Count
                colsCount = rngBlock.Columns.Count
                
                ' 1) Colonne A : nom d’onglet répété pour chaque ligne du bloc
                wsOut.Cells(destRow, 1).Resize(rowsCount, 1).Value = ws.Name
                
                ' 2) Coller TOUT le bloc (valeurs + formats + bordures + fusions + MFC) à partir de la colonne B
                rngBlock.Copy
                wsOut.Cells(destRow, 2).PasteSpecial Paste:=xlPasteAll
                ' 2bis) Reprendre les largeurs de colonnes de la source
                wsOut.Cells(destRow, 2).PasteSpecial Paste:=xlPasteColumnWidths
                Application.CutCopyMode = False
                
                ' 3) Reprendre les hauteurs de lignes du bloc
                For r = 1 To rowsCount
                    wsOut.Rows(destRow + r - 1).RowHeight = ws.Rows(r).RowHeight
                Next r
                
                ' 4) (Optionnel) Copier aussi les objets/graphes/images au bon offset
                If COPY_SHAPES_TOO Then
                    Dim shp As Shape, pasted As Shape
                    Dim topOffset As Double, leftOffset As Double
                    topOffset = wsOut.Cells(destRow, 2).Top - ws.Cells(1, 1).Top
                    leftOffset = wsOut.Cells(destRow, 2).Left - ws.Cells(1, 1).Left
                    
                    For Each shp In ws.Shapes
                        If IntersectsShapeRange(shp, rngBlock) Then
                            shp.Copy
                            wsOut.Paste
                            Set pasted = wsOut.Shapes(wsOut.Shapes.Count)
                            pasted.Top = shp.Top + topOffset
                            pasted.Left = shp.Left + leftOffset
                            On Error Resume Next
                            pasted.Placement = shp.Placement
                            pasted.LockAspectRatio = shp.LockAspectRatio
                            On Error GoTo 0
                        End If
                    Next shp
                End If
                
                ' 5) Avancer la position d’insertion sous le bloc
                If ADD_BLANK_LINE_BETWEEN Then
                    destRow = destRow + rowsCount + 1
                Else
                    destRow = destRow + rowsCount
                End If
            End If
        End If
    Next ws
    
    wsOut.Activate
    
CleanExit:
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    Application.Calculation = xlCalculationAutomatic
    Exit Sub

AddErr:
    MsgBox "Impossible d'ajouter une feuille dans ce classeur." & vbCrLf & _
           "Vérifiez que la structure du classeur n'est pas protégée " & _
           "(Révision > Protéger le classeur).", vbExclamation, "Erreur 1004 - Sheets.Add"
    Resume CleanExit
End Sub

' Nom de feuille unique (sans supprimer les existantes)
Private Function UniqueSheetName(wb As Workbook, baseName As String) As String
    Dim i As Long, candidate As String, exists As Boolean
    Dim wsCheck As Worksheet
    candidate = baseName: i = 1
    Do
        exists = False
        For Each wsCheck In wb.Worksheets
            If StrComp(wsCheck.Name, candidate, vbTextCompare) = 0 Then
                exists = True: Exit For
            End If
        Next wsCheck
        If Not exists Then
            UniqueSheetName = candidate
            Exit Function
        End If
        i = i + 1
        candidate = baseName & " (" & i & ")"
    Loop
End Function

' Détermine si une shape chevauche la plage (utile pour COPY_SHAPES_TOO)
Private Function IntersectsShapeRange(ByVal shp As Shape, ByVal rng As Range) As Boolean
    Dim sTop As Double, sLeft As Double, sBottom As Double, sRight As Double
    Dim rTop As Double, rLeft As Double, rBottom As Double, rRight As Double
    sTop = shp.Top: sLeft = shp.Left
    sBottom = shp.Top + shp.Height
    sRight = shp.Left + shp.Width
    rTop = rng.Top: rLeft = rng.Left
    rBottom = rng.Top + rng.Height
    rRight = rng.Left + rng.Width
    IntersectsShapeRange = Not (sRight < rLeft Or sLeft > rRight Or sBottom < rTop Or sTop > rBottom)
End Function